# vim: ts=2:sw=2:tw=80:nowrap

import Pyro4

from physical import unit

class Base(object):
  """Base channel class"""
  _padded_timing   = True
  _finite_end_clock = False

  # set of 'step', 'linear', and/or 'bezier'
  #
  # 'linear' : allows the output to linearly ramp from one value to another
  # 'step'   : each output remains fixed until a subsequent transition
  # 'bezier' : (speculated, not supported)
  #
  # This list defines what kind of transitions can be programmed.  Dumb channels
  # should generally allow 'step' type of transitions, where an output value is
  # static between transitions.
  #
  # this _can_ be overridden by a sub-class in order to define a channel with
  # other or multiple capabilities
  _capabilities = {'step'}

  def __init__(self, name, dev=None):
    super(Base,self).__init__()
    self._name = name
    self.dev = dev

  def __str__(self):
    return self._name

  def __repr__(self):
    return str(self)

  @Pyro4.expose
  @property
  def name(self):
    return self._name

  @Pyro4.expose
  @property
  def config_template(self):
    return self.get_config_template()

  @Pyro4.expose
  def get_config_template(self):
    return dict()

  @Pyro4.expose
  @property
  def prefix(self):
    return self._name.partition('/')[0]

  @Pyro4.expose
  @property
  def device(self):
    return self.dev

  @Pyro4.expose
  @property
  def device_str(self):
    """
    This interface is provided primarily for speed and easiness for
    get_output_channels_attrib (and because we do need the device string).
    """
    return str(self.dev)

  @Pyro4.expose
  @property
  def padded_timing(self):
    """
    Identifies a channel that simply writes an output value for every clock.
    This type requires padding, for when a clock must occur but an output is not
    requested to change.  This is typical for hardware like NI hardware that
    uses a simple FIFO style buffer for generating output on every clock.
    """
    return self._padded_timing

  def get_min_period(self):
    """
    Returns the minimum timing period (period between two rising edges of this
    clock pulse) in units of seconds.

    This one should be overridden by sub-classes.
    """
    return 0*unit.s

  @Pyro4.expose
  @property
  def min_period(self):
    """
    Attrib access to get_min_period for Pyro4--but used in compute.py everywhere
    for consistency with Pyro4.

    This one should not be overridden by sub-classes.
    """
    return self.get_min_period()

  @Pyro4.expose
  @property
  def finite_mode_requires_end_clock(self):
    """
    Identifies a channel as requiring a special extra clock pulse at the end of
    the sequence in _non-continuous_ mode so that the hardware will recognize
    the end of the sequence (and also thus notify the software).  Currently,
    only NI hardware is known to require this.

    !!!!NOTE!!!!
    For any driver/channel that defines this requirement, an extra transition
    will be generated by its clock in order to faciltate this last transition.
    Thus, it is necessary that the driver/channel ignore the last transition
    that is given to its clock source when the output is not in continuous mode.
    """
    return self._finite_end_clock

  @Pyro4.expose
  @property
  def type(self):
    return self._type

  @Pyro4.expose
  @property
  def capabilities(self):
    """
    set of 'step', 'linear', and/or 'bezier'

    'linear' : allows the output to linearly ramp from one value to another
    'step'   : each output remains fixed until a subsequent transition
    'bezier' : (speculated, not supported)

    This list defines what kind of transitions can be programmed.  Dumb channels
    should generally allow 'step' type of transitions, where an output value is
    static between transitions.
    """
    return self._capabilities

1.  Verify that all the devices of a particular loaded configuration file are
  valid.
  It is probably critical that this verification and subsequent error handling
  is not done just after loading a file.  It may certainly be desirable to
  edit/view a configuration on a computer without devices.  This the proper
  time for verification is probably at the time that the run button is
  depressed.  Once verification has happened, perhaps we might just cache the
  result and only re-evaluate the validity of the current configuration if
  something has changed.

2.  Have hardware update when some setting on the front panel changes.
  This update should ONLY update the hardware that actually changed.
    a.  This might be accomplished by the individual hardware each storing a last
      copy of the configuration assigned to it and comparing the new
      configuration to it.  This would probably be the easiest way to implement
      this feature.
      This might also allow the hardware drivers to actually only select a
      portion of their configuration to update (if this is feasible).  This
      might actually end up providing the least lag time on average (as measured
      from mouse/key click to hardware output).

    b.  This _could_ also be accomplished by the program where it senses whether
      a set of changes applies to which hardware.  this _might_ be faster,
      though slightly more complicated.

  I cannot see a reason why updates should be made to _all_ hardware
  regardless of which hardware is really effected by a particular change.  It
  seems that user-responsiveness _could_ be significantly improved by only
  updating hardware that needs updating.

3.  Have some syntax highlighting in the script editor.  There is a simpler
  version in the pygtk-demo program (not the demos, but the demo program
  itsself).  This isn't perfect, but will be much easier to port, maintain than
  perhaps using a full-fledged editor that we have to import from some other
  project.

4.  Figure out how to handle automatic clocking for ramps where it is probably
  desirable to specify the resolution of the ramp.  Somehow, we need to specify
  a time resolution for these kind of pieces.  Perhaps in the 'time' column, we
  allow the user to specify a tuple like '(duration, step)'.  Then, when we are
  processing the time column and discovering all the transition for
  automatically creating the clocks and local time, we sense whether a time-cell
  has a tuple/list type or a simple numeric type.

  Generally, for automatic clocking we need to determine the time of all
  possible voltage/logic transitions for each device clock (it might be possible
  to have different arbitrary clocks for different devices).  Then, once we have
  the location of all necessary clock pulses, we loop through each 'value' cell
  and use the local set of the arbitrary clock pulses to determine how many
  samples to create for each value.

